{"ast":null,"code":"function _inheritsLoose(subClass, superClass) {\n  subClass.prototype = Object.create(superClass.prototype);\n  subClass.prototype.constructor = subClass;\n  subClass.__proto__ = superClass;\n}\n/* eslint-disable react/no-find-dom-node */\n\n\nimport React, { Component, useEffect, useMemo, useRef, useState } from 'react';\nimport { findDOMNode } from 'react-dom';\nimport { findScrollParents } from '../../utils';\nimport { Box } from '../Box'; // Wraps an item to ensure we can get a ref to it\n\nvar Ref = /*#__PURE__*/function (_Component) {\n  _inheritsLoose(Ref, _Component);\n\n  function Ref() {\n    return _Component.apply(this, arguments) || this;\n  }\n\n  var _proto = Ref.prototype;\n\n  _proto.render = function render() {\n    var children = this.props.children;\n    return children;\n  };\n\n  return Ref;\n}(Component);\n\nvar InfiniteScroll = function InfiniteScroll(_ref) {\n  var children = _ref.children,\n      _ref$items = _ref.items,\n      items = _ref$items === void 0 ? [] : _ref$items,\n      onMore = _ref.onMore,\n      renderMarker = _ref.renderMarker,\n      replace = _ref.replace,\n      show = _ref.show,\n      _ref$step = _ref.step,\n      step = _ref$step === void 0 ? 50 : _ref$step; // the last page we have items for\n\n  var lastPage = useMemo(function () {\n    return Math.floor(items.length / step);\n  }, [items.length, step]); // the first page we are displaying\n\n  var _useState = useState(0),\n      beginPage = _useState[0],\n      setBeginPage = _useState[1]; // the last page we are displaying\n\n\n  var _useState2 = useState(show ? Math.floor((show + step) / step) - 1 : 0),\n      endPage = _useState2[0],\n      setEndPage = _useState2[1]; // how tall we've measured a page to be\n\n\n  var _useState3 = useState(),\n      pageHeight = _useState3[0],\n      setPageHeight = _useState3[1]; // how much area a page requires\n\n\n  var _useState4 = useState(),\n      pageArea = _useState4[0],\n      setPageArea = _useState4[1]; // whether the items are laid out in a grid instead of linearly\n\n\n  var _useState5 = useState(),\n      multiColumn = _useState5[0],\n      setMultiColumn = _useState5[1]; // what we're waiting for onMore to give us\n\n\n  var _useState6 = useState(0),\n      pendingLength = _useState6[0],\n      setPendingLength = _useState6[1];\n\n  var belowMarkerRef = useRef();\n  var firstPageItemRef = useRef();\n  var lastPageItemRef = useRef();\n  var showRef = useRef(); // calculating space based on where the first and last items being displayed\n  // are located\n\n  useEffect(function () {\n    if (firstPageItemRef.current && lastPageItemRef.current && !pageHeight) {\n      /* eslint-disable react/no-find-dom-node */\n      var beginRect = findDOMNode(firstPageItemRef.current).getBoundingClientRect();\n      var endRect = findDOMNode(lastPageItemRef.current).getBoundingClientRect();\n      var nextPageHeight = endRect.top + endRect.height - beginRect.top; // Check if the items are arranged in a single column or not.\n\n      var nextMultiColumn = nextPageHeight / step < endRect.height;\n      var nextPageArea = endRect.height * endRect.width * step;\n      setPageHeight(nextPageHeight);\n      setPageArea(nextPageArea);\n      setMultiColumn(nextMultiColumn);\n    }\n  }, [pageHeight, step]); // scroll handling\n\n  useEffect(function () {\n    var scrollParents;\n\n    var onScroll = function onScroll() {\n      var scrollParent = scrollParents[0]; // Determine the window into the first scroll parent\n\n      var top;\n      var height;\n      var width;\n\n      if (scrollParent === document) {\n        top = document.documentElement.scrollTop || document.body.scrollTop;\n        height = window.innerHeight;\n        width = window.innerWidth;\n      } else {\n        top = scrollParent.scrollTop;\n        var rect = scrollParent.getBoundingClientRect();\n        height = rect.height;\n        width = rect.width;\n      } // Figure out which pages we should make visible based on the scroll\n      // window.\n\n\n      var offset = height / 4;\n      var nextBeginPage = replace ? Math.min(lastPage, Math.max(0, multiColumn ? Math.floor(Math.max(0, top - offset) * width / pageArea) : Math.floor(Math.max(0, top - offset) / pageHeight))) : 0;\n      var nextEndPage = Math.min(lastPage, Math.max(!replace && endPage || 0, multiColumn ? Math.ceil((top + height + offset) * width / pageArea) : Math.floor((top + height + offset) / pageHeight)));\n      if (nextBeginPage !== beginPage) setBeginPage(nextBeginPage);\n      if (nextEndPage !== endPage) setEndPage(nextEndPage);\n    };\n\n    if (pageHeight && belowMarkerRef.current) {\n      scrollParents = findScrollParents(belowMarkerRef.current);\n      scrollParents.forEach(function (scrollParent) {\n        return scrollParent.addEventListener('scroll', onScroll);\n      });\n      onScroll();\n    }\n\n    return function () {\n      if (scrollParents) {\n        scrollParents.forEach(function (scrollParent) {\n          return scrollParent.removeEventListener('scroll', onScroll);\n        });\n      }\n    };\n  }, [beginPage, endPage, lastPage, multiColumn, pageArea, pageHeight, replace]); // check if we need to ask for more\n\n  useEffect(function () {\n    if (onMore && endPage === lastPage && items.length >= pendingLength) {\n      // remember we've asked for more, so we don't keep asking if it takes\n      // a while\n      setPendingLength(items.length + 1);\n      onMore();\n    }\n  }, [endPage, items.length, lastPage, onMore, pendingLength, step]); // scroll to any 'show'\n\n  useEffect(function () {\n    // ride out any animation delays, 100ms empirically measured\n    var timer = setTimeout(function () {\n      if (show && showRef.current) {\n        findDOMNode(showRef.current).scrollIntoView();\n      }\n    }, 100);\n    return function () {\n      return clearTimeout(timer);\n    };\n  }, [show]);\n  var firstIndex = beginPage * step;\n  var lastIndex = Math.min((endPage + 1) * step, items.length) - 1;\n  var result = [];\n\n  if (replace && pageHeight && firstIndex) {\n    var marker = React.createElement(Box, {\n      key: \"above\",\n      flex: false,\n      height: beginPage * pageHeight + \"px\"\n    });\n\n    if (renderMarker) {\n      // need to give it a key\n      marker = React.cloneElement(renderMarker(marker), {\n        key: 'above'\n      });\n    }\n\n    result.push(marker);\n  }\n\n  items.slice(firstIndex, lastIndex + 1).forEach(function (item, index) {\n    var itemsIndex = firstIndex + index;\n    var child = children(item, itemsIndex); // we only need the Refs if we don't know the pageHeight\n\n    if (!pageHeight && itemsIndex === 0) {\n      child = React.createElement(Ref, {\n        key: \"first\",\n        ref: firstPageItemRef\n      }, child);\n    } else if (!pageHeight && (itemsIndex === step - 1 || itemsIndex === lastIndex)) {\n      child = React.createElement(Ref, {\n        key: \"last\",\n        ref: lastPageItemRef\n      }, child);\n    }\n\n    if (show && show === itemsIndex) {\n      child = React.createElement(Ref, {\n        key: \"show\",\n        ref: showRef\n      }, child);\n    }\n\n    result.push(child);\n  });\n\n  if (endPage < lastPage || replace || onMore) {\n    var _marker = React.createElement(Box, {\n      key: \"below\",\n      ref: belowMarkerRef,\n      flex: false,\n      height: (replace ? (lastPage - endPage) * pageHeight : 0) + \"px\"\n    });\n\n    if (renderMarker) {\n      // need to give it a key\n      _marker = React.cloneElement(renderMarker(_marker), {\n        key: 'below'\n      });\n    }\n\n    result.push(_marker);\n  }\n\n  return result;\n};\n\nvar InfiniteScrollDoc;\n\nif (process.env.NODE_ENV !== 'production') {\n  // eslint-disable-next-line global-require\n  InfiniteScrollDoc = require('./doc').doc(InfiniteScroll);\n}\n\nvar InfiniteScrollWrapper = InfiniteScrollDoc || InfiniteScroll;\nexport { InfiniteScrollWrapper as InfiniteScroll };","map":{"version":3,"sources":["C:/compare-app/node_modules/grommet/es6/components/InfiniteScroll/InfiniteScroll.js"],"names":["_inheritsLoose","subClass","superClass","prototype","Object","create","constructor","__proto__","React","Component","useEffect","useMemo","useRef","useState","findDOMNode","findScrollParents","Box","Ref","_Component","apply","arguments","_proto","render","children","props","InfiniteScroll","_ref","_ref$items","items","onMore","renderMarker","replace","show","_ref$step","step","lastPage","Math","floor","length","_useState","beginPage","setBeginPage","_useState2","endPage","setEndPage","_useState3","pageHeight","setPageHeight","_useState4","pageArea","setPageArea","_useState5","multiColumn","setMultiColumn","_useState6","pendingLength","setPendingLength","belowMarkerRef","firstPageItemRef","lastPageItemRef","showRef","current","beginRect","getBoundingClientRect","endRect","nextPageHeight","top","height","nextMultiColumn","nextPageArea","width","scrollParents","onScroll","scrollParent","document","documentElement","scrollTop","body","window","innerHeight","innerWidth","rect","offset","nextBeginPage","min","max","nextEndPage","ceil","forEach","addEventListener","removeEventListener","timer","setTimeout","scrollIntoView","clearTimeout","firstIndex","lastIndex","result","marker","createElement","key","flex","cloneElement","push","slice","item","index","itemsIndex","child","ref","_marker","InfiniteScrollDoc","process","env","NODE_ENV","require","doc","InfiniteScrollWrapper"],"mappings":"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","sourcesContent":["function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }\n\n/* eslint-disable react/no-find-dom-node */\nimport React, { Component, useEffect, useMemo, useRef, useState } from 'react';\nimport { findDOMNode } from 'react-dom';\nimport { findScrollParents } from '../../utils';\nimport { Box } from '../Box'; // Wraps an item to ensure we can get a ref to it\n\nvar Ref =\n/*#__PURE__*/\nfunction (_Component) {\n  _inheritsLoose(Ref, _Component);\n\n  function Ref() {\n    return _Component.apply(this, arguments) || this;\n  }\n\n  var _proto = Ref.prototype;\n\n  _proto.render = function render() {\n    var children = this.props.children;\n    return children;\n  };\n\n  return Ref;\n}(Component);\n\nvar InfiniteScroll = function InfiniteScroll(_ref) {\n  var children = _ref.children,\n      _ref$items = _ref.items,\n      items = _ref$items === void 0 ? [] : _ref$items,\n      onMore = _ref.onMore,\n      renderMarker = _ref.renderMarker,\n      replace = _ref.replace,\n      show = _ref.show,\n      _ref$step = _ref.step,\n      step = _ref$step === void 0 ? 50 : _ref$step;\n  // the last page we have items for\n  var lastPage = useMemo(function () {\n    return Math.floor(items.length / step);\n  }, [items.length, step]); // the first page we are displaying\n\n  var _useState = useState(0),\n      beginPage = _useState[0],\n      setBeginPage = _useState[1]; // the last page we are displaying\n\n\n  var _useState2 = useState(show ? Math.floor((show + step) / step) - 1 : 0),\n      endPage = _useState2[0],\n      setEndPage = _useState2[1]; // how tall we've measured a page to be\n\n\n  var _useState3 = useState(),\n      pageHeight = _useState3[0],\n      setPageHeight = _useState3[1]; // how much area a page requires\n\n\n  var _useState4 = useState(),\n      pageArea = _useState4[0],\n      setPageArea = _useState4[1]; // whether the items are laid out in a grid instead of linearly\n\n\n  var _useState5 = useState(),\n      multiColumn = _useState5[0],\n      setMultiColumn = _useState5[1]; // what we're waiting for onMore to give us\n\n\n  var _useState6 = useState(0),\n      pendingLength = _useState6[0],\n      setPendingLength = _useState6[1];\n\n  var belowMarkerRef = useRef();\n  var firstPageItemRef = useRef();\n  var lastPageItemRef = useRef();\n  var showRef = useRef(); // calculating space based on where the first and last items being displayed\n  // are located\n\n  useEffect(function () {\n    if (firstPageItemRef.current && lastPageItemRef.current && !pageHeight) {\n      /* eslint-disable react/no-find-dom-node */\n      var beginRect = findDOMNode(firstPageItemRef.current).getBoundingClientRect();\n      var endRect = findDOMNode(lastPageItemRef.current).getBoundingClientRect();\n      var nextPageHeight = endRect.top + endRect.height - beginRect.top; // Check if the items are arranged in a single column or not.\n\n      var nextMultiColumn = nextPageHeight / step < endRect.height;\n      var nextPageArea = endRect.height * endRect.width * step;\n      setPageHeight(nextPageHeight);\n      setPageArea(nextPageArea);\n      setMultiColumn(nextMultiColumn);\n    }\n  }, [pageHeight, step]); // scroll handling\n\n  useEffect(function () {\n    var scrollParents;\n\n    var onScroll = function onScroll() {\n      var scrollParent = scrollParents[0]; // Determine the window into the first scroll parent\n\n      var top;\n      var height;\n      var width;\n\n      if (scrollParent === document) {\n        top = document.documentElement.scrollTop || document.body.scrollTop;\n        height = window.innerHeight;\n        width = window.innerWidth;\n      } else {\n        top = scrollParent.scrollTop;\n        var rect = scrollParent.getBoundingClientRect();\n        height = rect.height;\n        width = rect.width;\n      } // Figure out which pages we should make visible based on the scroll\n      // window.\n\n\n      var offset = height / 4;\n      var nextBeginPage = replace ? Math.min(lastPage, Math.max(0, multiColumn ? Math.floor(Math.max(0, top - offset) * width / pageArea) : Math.floor(Math.max(0, top - offset) / pageHeight))) : 0;\n      var nextEndPage = Math.min(lastPage, Math.max(!replace && endPage || 0, multiColumn ? Math.ceil((top + height + offset) * width / pageArea) : Math.floor((top + height + offset) / pageHeight)));\n      if (nextBeginPage !== beginPage) setBeginPage(nextBeginPage);\n      if (nextEndPage !== endPage) setEndPage(nextEndPage);\n    };\n\n    if (pageHeight && belowMarkerRef.current) {\n      scrollParents = findScrollParents(belowMarkerRef.current);\n      scrollParents.forEach(function (scrollParent) {\n        return scrollParent.addEventListener('scroll', onScroll);\n      });\n      onScroll();\n    }\n\n    return function () {\n      if (scrollParents) {\n        scrollParents.forEach(function (scrollParent) {\n          return scrollParent.removeEventListener('scroll', onScroll);\n        });\n      }\n    };\n  }, [beginPage, endPage, lastPage, multiColumn, pageArea, pageHeight, replace]); // check if we need to ask for more\n\n  useEffect(function () {\n    if (onMore && endPage === lastPage && items.length >= pendingLength) {\n      // remember we've asked for more, so we don't keep asking if it takes\n      // a while\n      setPendingLength(items.length + 1);\n      onMore();\n    }\n  }, [endPage, items.length, lastPage, onMore, pendingLength, step]); // scroll to any 'show'\n\n  useEffect(function () {\n    // ride out any animation delays, 100ms empirically measured\n    var timer = setTimeout(function () {\n      if (show && showRef.current) {\n        findDOMNode(showRef.current).scrollIntoView();\n      }\n    }, 100);\n    return function () {\n      return clearTimeout(timer);\n    };\n  }, [show]);\n  var firstIndex = beginPage * step;\n  var lastIndex = Math.min((endPage + 1) * step, items.length) - 1;\n  var result = [];\n\n  if (replace && pageHeight && firstIndex) {\n    var marker = React.createElement(Box, {\n      key: \"above\",\n      flex: false,\n      height: beginPage * pageHeight + \"px\"\n    });\n\n    if (renderMarker) {\n      // need to give it a key\n      marker = React.cloneElement(renderMarker(marker), {\n        key: 'above'\n      });\n    }\n\n    result.push(marker);\n  }\n\n  items.slice(firstIndex, lastIndex + 1).forEach(function (item, index) {\n    var itemsIndex = firstIndex + index;\n    var child = children(item, itemsIndex); // we only need the Refs if we don't know the pageHeight\n\n    if (!pageHeight && itemsIndex === 0) {\n      child = React.createElement(Ref, {\n        key: \"first\",\n        ref: firstPageItemRef\n      }, child);\n    } else if (!pageHeight && (itemsIndex === step - 1 || itemsIndex === lastIndex)) {\n      child = React.createElement(Ref, {\n        key: \"last\",\n        ref: lastPageItemRef\n      }, child);\n    }\n\n    if (show && show === itemsIndex) {\n      child = React.createElement(Ref, {\n        key: \"show\",\n        ref: showRef\n      }, child);\n    }\n\n    result.push(child);\n  });\n\n  if (endPage < lastPage || replace || onMore) {\n    var _marker = React.createElement(Box, {\n      key: \"below\",\n      ref: belowMarkerRef,\n      flex: false,\n      height: (replace ? (lastPage - endPage) * pageHeight : 0) + \"px\"\n    });\n\n    if (renderMarker) {\n      // need to give it a key\n      _marker = React.cloneElement(renderMarker(_marker), {\n        key: 'below'\n      });\n    }\n\n    result.push(_marker);\n  }\n\n  return result;\n};\n\nvar InfiniteScrollDoc;\n\nif (process.env.NODE_ENV !== 'production') {\n  // eslint-disable-next-line global-require\n  InfiniteScrollDoc = require('./doc').doc(InfiniteScroll);\n}\n\nvar InfiniteScrollWrapper = InfiniteScrollDoc || InfiniteScroll;\nexport { InfiniteScrollWrapper as InfiniteScroll };"]},"metadata":{},"sourceType":"module"}